<div class="page-header">
  <h1>Viikko 3</h1>
</div>
<h2>Sisällysluettelo</h2>
<ul class="nav nav-pills nav-stacked">
  <li><a href="" ng-click="goto_anchor('1-php-haltuun')">1. PHP haltuun</a></li>
  <li><a href="" ng-click="goto_anchor('2-mallit')">2. Mallit</a></li>
  <li><a href="" ng-click="goto_anchor('3-kontrollerit-ja-mallit')">3. Kontrollerit ja mallit</a></li>
  <li><a href="" ng-click="goto_anchor('4-lomakkeet-ja-lisaystoiminnot')">4. Lomakkeet ja lisäystoiminnot</a></li>
  <li><a href="" ng-click="goto_anchor('5-palautuksen-vaatimukset')">5. Palautuksen vaatimukset</a></li>
</ul>

<hr>
<a id="1-php-haltuun"></a>
<h2>1. PHP haltuun</h2>
<p>
  Ennen kuin etenemme sovelluksemme toteutuksessa pidemmälle, sukelletaan hetkeksi PHP:n saloihin.
</p>
<h3>1.1 Taulukot ja assosiaatiolistat</h3>

<p>
  PHP:n luultavasti tärkein tietorakenne on <strong>taulukko</strong> (<code>array</code>), joka on kokoelma otuksia, kuten merkkijonoja, kokonaislukuja, tai toisia taulukoita. Koska PHP on tyypitön, voi taulukko koostua erityyppisistä arvoista, vaikkin se voi olla hieman sekavaa. Taulukon alustaminen on helppoa, tässä on esimerkki taulukosta merkkijonoja:
</p>

<div hljs no-escape>$kaverit = array('Henri', 'Elina', 'Riku', 'Viivi', 'Jorma', 'Teo');</div>

<p>
  Nyt <code>$kaverit</code>-muuttujassa on taulukko, jossa on kuusi merkkijonoa. Katsotaan, mitä voimme saada irti tästä taulukosta:
</p>

<div hljs no-escape>echo 'Kallen esimmäinen kaveri on:\n';
echo $kaverit[0] . '\n';
// Henri
echo 'Kallen viimeinen kaveri on:\n';
echo $kaverit[5] . '\n';
// Teo
echo 'Kallen kavereita ovat:\n'
foreach($kaverit as $kaveri){
  echo $kaveri . '\n';
  // Tähän tulostuu kaverin nimi
}
// Lisätään Kallelle kaveri
$kaverit[] = 'Helena';
echo 'Kallen viimeinen kaveri on:\n';
echo $kaverit[6] . '\n';
// Helena
echo 'Kallella on yhteensä ' . count($kaverit) . ' kaveria';
// Kallella on yhteensä 7 kaveria
</div>

<p>
  Merkkijonon alkioihin voi siis Javan tapaan viitata indeksillä, jolloin esimmäinen alkio on indeksissä 0. <code>$kaverit[0]</code> on siis taulukon ensimmäinen alkio. Taulukon läpikäyntiin voi käyttää <code>foreach</code>-looppia, johon annetaan iteroitava taulukko ja iteroitavan alkion nimi. Iteroitavaan alkioon voi viitata loopin sisällä, jolloin esimerkissä tulostuu kaikki taulukon alkiot.
</p>

<p>
  Taulukkoon voi myös helposti lisätä alkioita. Se tapahtuu esimerkissä kohdassa <code>$kaverit[] = 'Helena'</code>. Alkion lisääminen taulukkoon onnistuu myös <a href="http://php.net/manual/en/function.array-push.php" target="_blank">array_push</a>-funktion avulla, jolloin esimerkissä alkion <code>'Helena'</code> voisi lisätä taulukkoon <code>$kaverit</code> kutsulla <code>array_push($kaverit, 'Helena')</code>. Toinen hyödyllinen taulukkoihin liittyvä funktio on <a href="http://php.net/manual/en/function.count.php" target="_blank">count</a>, joka palauttaa taulukon alkioiden lukumäärän.
</p>

<p>
  Toinen erittäin tärkeä tietorakenne on <strong>assosiaatiolista</strong>, joka muistuttaa Javan HashMap:ia. Assosiaatiolista koostuu avain-arvo-pareista, joka esitetään seuraavasti:
</p>

<div hljs no-escape>$iat = array(
  'kalle' => 22,
  'elina' => 24,
  'henri' => 21
);</div>

<p>
  <code>$iat</code>-assosiaatiolistassa on avaimet <code>kalle</code>, <code>elina</code> ja <code>henri</code> ja niitä vastaavat arvot <code>22</code>, <code>24</code>, <code>21</code>. <strong>Assosiaatiolistan avaimen täytyy aina olla merkkijono</strong>. Katsotaan, miten voimme käsitellä assosiaatiolistoja:
</p>

<div hljs no-escape>echo 'Kalle on ' . $iat['kalle'] . ' vuotta vanha\n';
// Kalle on 22 vuotta vanha
echo 'Elina on ' . $iat['elina'] . ' vuotta vanha\n';
// Elina on 24 vuotta vanha
echo 'Henri on ' . $iat['henri'] . ' vuotta vanha\n';
// Henri on 21 vuotta vanha
// Kallella on syntymäpäivät, vaihdetaan hänen ikänsä
$iat['kalle'] = 23;
echo 'Kalle on ' . $iat['kalle'] . ' vuotta vanha\n';
// Kalle on 23 vuotta vanha</div>

<p>
  Kuten esimerkistä näkee, assosiaatiolistan avainta vastaavan arvon saa syntaksilla <code>$lista['avain']</code>, jolloin avaimen <code>kalle</code> arvo esimerkissä <code>$iat['kalle']</code>. Avaimen arvoa voi myös muuttaa, kuten esimerkissä avaimen <code>kalle</code> arvoksi asetettiin <code>23</code>, kohdassa <code>$iat['kalle'] = 23</code>.
</p>

<h3>1.2 Luokat</h3>

<p>
  Katsotaan seuraavaksi lyhyesti, miten Javasta tutut <strong>luokat</strong> toteutetaan PHP:ssa. Tässä on esimerkki luokasta <code>Koira</code>:
</p>

<div hljs no-escape>class Koira{
  // attribuutit
  public $nimi, $omistaja, $paino, $ika;
  // konstruktori
  public function __construct($nimi, $omistaja, $paino, $ika){
    $this->nimi = $nimi;
    $this->omistaja = $omistaja;
    $this->paino = $paino;
    $this->ika = $ika;
  }
  // olioon liittyvä julkinen metodi
  public function hauku(){
    $sanonta = $this->mita_koira_sanoo();
    return $this->nimi . ': ' . $sanonta;
  }
  // luokkaan liittyvä staattinen metodi
  public static function eliokunta(){
    return 'Nisäkkäät';
  }
  // olioon liittyvä privaatti metodi
  private function mita_koira_sanoo(){
    return 'Hau, hau!';
  }
}</div>

<p>
  Esimerkissä <code>Koira</code>-luokkaan liittyy neljä attribuuttia - <code>$nimi</code>, <code>$omistaja</code>, <code>$paino</code> ja <code>$ika</code>. Attribuuttien näkyvyysalueeksi on asetettu <code>pulic</code>, joten niihin pääsee käsiksi kaikkialta, myös luokan ulkopuolelta. Luokan konstruktori määritetään metodissa <code>__construct</code>, joka ottaa parametreikseen kaikki koiraan liittyvät tiedot. Olion attribuutteihin pystyy viittamaan syntaksilla <code>$this->attribuutin_nimi</code>, jolloin esimerkissä nimi attribuutin arvo on <code>$this->nimi</code>.
</p>

<p>
  Luokalla voi olla sen olioon liittyviä metodeja, tai itse luokkaan liittyviä metodeja, eli staattisia metodeja (<code>static</code>). <code>Koira</code>-luokalle on määritelty oliometodit <code>hauku</code> ja <code>mita_koira_sanoo</code> sekä staattinen metodi <code>eliokunta</code>. Tässä pieni esimerkki <code>Koira</code>-luokan käytöstä:
</p>

<div hljs no-escape>$rekku = new Koira('Rekku', 'Kalle', 10, 2);
echo $rekku->nimi;
// Rekku
echo $rekku->hauku();
// Rekku: Hau, hau!
echo Koira::eliokunta();
// Nisäkkäät</div>

<p>
  <div class="alert alert-info">
    <h4>Vinkki</h4>
    <a href="http://phpfiddle.org/" target="_blank">PhpFiddle</a> on hyvä paikka kokeilla yllä esitettyjä esimerkkejä, tai omia koodinpätkiä. Jos innostuit PHP:n opiskelusta, löytyy <a href="http://www.w3schools.com/php/" target="_blank">W3Schools</a>:ista läjäpäin hyviä PHP-tutoriaaleja.
  </div>
</p>
<hr>
<a id="2-mallit"></a>
<h2>2. Mallit</h2>

<p>
  Palataan taas ensimmäisellä viikolla esitettyyn esimerkkiin ja muistellaan, mitä siinä puhuttiin malleista:
</p>

<blockquote>
  <ol>
    <li>...</li>
    <li>...</li>
    <li>Kun kontrolleri ja metodi löytyy, sitä kutsutaan. Kontrolleri pyytää kurssien hallinnasta vastuussa olevalta mallilta kaikki tämän vuosineljänneksen kurssit.</li>
    <li>Kurssien hallinnasta vastuussa oleva malli hakee tietokannasta kaikki vuosineljänneksen kurssit, muodostaa niistä sovelluksen olioita ja palauttaa ne kontrollerille.</li>
    <li>Saatuaan haluamansa kurssit, kontrolleri pyytää kurssien listaa muodostavaa näkymää renderöimään itseensä mallilta haetuilla kursseilla...</li>
  </ol>
</blockquote>

Malli siis edustaa jotain sovelluksen tietokohdetta, kuten esimerkissämme, kurssia ja tarjoaa kontrollereille tietokannan muokkaamiseen ja hakuun liittyviä palveluita.

<h3>2.1 Oman sovelluksemme mallit</h3>

<p>
  Katsotaan seuraavaksi, miten mallit käytännössä toteutetaan. Omassa sovelluksessani minun täytyy jotenkin suorittaa peleihin liittyviä tietokantaoperaatiota. Tarvitsen siis pelille mallin. Lisään <code>app/models</code>-kansioon tiedoston <code>game.php</code>, johon toteutan malliluokkani. Tässä on <code>Game</code>-luokan runko:
</p>
<div hljs language="php" no-escape>class Game extends BaseModel{
    // ...
}</div>

<p>
  <div class="alert alert-warning">
    <h4>Muistathan?</h4>
    Muista lisätä jokaisen luomasi <code>php</code>-tiedoston alkuun rivi <code>&lt;?php</code>.
  </div>
</p>

<p>
  Muista periä luokka <code>BaseModel</code>, niin pääset käyttämään sen tarjoamia metodeja. Lisään seuraavaksi peliin liittyvät attribuutit ja luokalleni konstruktorin:
</p>

<div hljs language="php" no-escape>class Game extends BaseModel{
  // Attribuutit
  public $id, $player_id, $name, $played, $description, $published, $publisher, $added;
  // Konstruktori
  public function __construct($attributes){
    parent::__construct($attributes);
  }
}</div>

<p>
  <code>__construct</code>-metodi on siis luokkani <a href="http://php.net/manual/en/language.oop5.decon.php" target="_blank">konstruktori</a>. Kutsun siinä yläluokan konstruktoria, jonka avulla voin alustaa olion seuraavasti:
</p>

<div hljs language="php" no-escape>$skyrim = new Game(array('id' => 1, 'name' => 'The Elder Scrolls V: Skyrim', 'description' => 'Arrow to the knee'));</div>

<p>
  Tämä konstruktori on monella tapaa kätevämpi kuin tavanomainen, mm. sen takia, ettei ole väliä, missä järjestyksessä parametrit antaa, tai antaako niitä ollenkaan. Voin siis asettaa haluamani attribuutit antamalla konstruktorille <a href="http://php.net/manual/en/language.types.array.php" target="_blank">assosiaatiolistan</a>, joka sisältää avain-arvo-pareja. Pääset assosiaatiolistassa avaimen arvoon syntaksilla <code>$lista['avain']</code>. Voit halutessasi luoda myös erilaisen konstruktorin. Pääsemme nyt käsiksi luomamme olion attribuutteihin <code>-></code>-syntaksilla:
</p>

<div hljs language="php" no-escape>echo $skyrim->name;
// The Elder Scrolls V: Skyrim</div>

<p>
  Jos haluat päästä käsiksi attribuutteihin luokan sisällä, onnistuu se <code>$this->attribuutin_nimi</code>-syntaksilla, jolloin esimerkin <code>name</code>-attribuutin arvo on <code>$this->name</code>. Yläluokan konstruktorin toteutus löytyy tiedostosta <code>lib/base_model.php</code>.
</p>

<p>
  Minun täytyy seuraavaksi toteuttaa metodi, joka hakee kaikki pelit tietokannasta ja palauttee ne <code>Game</code>-olioina. Sen ei pitäisi olla vaikeaa, minun täytyy tehdä vain <code>SELECT * FROM Game</code> kysely tietokantaani ja käydä läpi sen tuottamat rivit. Katsotaan, miten tämä käytännössä tapahtuu:
</p>

<div hljs language="php" no-escape>class Game extends BaseModel{
  // ...
  public static function all(){
    // Alustetaan kysely tietokantayhteydellämme
    $query = DB::connection()->prepare('SELECT * FROM Game');
    // Suoritetaan kysely
    $query->execute();

    // Haetaan kyselyn tuottamat rivit
    $rows = $query->fetchAll();
    $games = array();

    // Käydään kyselyn tuottamat rivit läpi
    foreach($rows as $row){
      // Tämä on PHP:n hassu syntaksi alkion lisäämiseksi taulukkoon :)
      $games[] = new Game(array(
        'id' => $row['id'],
        'player_id' => $row['player_id'],
        'name' => $row['name'],
        'played' => $row['played'],
        'description' => $row['description'],
        'published' => $row['published'],
        'publisher' => $row['publisher'],
        'added' => $row['added']
      ));
    }

    return $games;
  }
}</div>

<p>
  Käydäänpä läpi, mitä metodissa tapahtuu. Määrittelen aluksi staattisen metodin <code>all</code> ja kutsun <code>DB</code>-luokan staattista metodia <code>connection</code>, joka palauttaa <strong><a href="http://php.net/manual/en/book.pdo.php" target="_blank">PDO</a></strong>-tietokantakirjaston tarjoaman PDO-yhteysolion. Alustan tietokantakyselyn kutsumalla PDO-yhteysolion metodia <code>prepare</code>, joka ottaa parametrikseen suoritettavan tietokantakyselyn. Seuraavalla rivillä suoritan kyselyni kutsumalla <code>execute</code>-metodia. Kyselyn suorittamisen jälkeen kyselyn tuottamiin riveihin pääsee käsiksi kutsumalla <code>fetchAll</code>-metodia, joka palauttaa rivit taulukkona assosiaatiolistoja, jonka avaimina toimivat sarakkeiden nimet ja arvoina niiden sisältö. Käyn rivit läpi <code>foreach</code>-loopissa ja luon jokaisen rivin arvoista <code>Game</code>-olion, jonka lisään <code>games</code>-taulukkoon.
</p>

<p>
  <div class="alert alert-info">
    <h4>Vinkki</h4>
    Tietokantakyselyitä kannattaa kokeilla <code>psql</code>-komentotulkissa ennen kuin käytät niitä malleissa, jotta voit olla varma, että ne toimivat haluamallasi tavalla. Muistathan, että pääset käyttämään komentotulkkia ottamalla SSH-yhteyden users-palvelimeen komennolla <code>ssh kayttajatunnus@users.cs.helsinki.fi</code> (korvaa kohta <code>kayttajatunnus</code> omalla CS-käyttäjätunnuksellasi) ja suorittamalla users-palvelimen puolella komennon <code>psql</code>. Kun testaamasi tietokantakysely toimii, voit sulkea komentotulkin syöttämällä <code>\q</code> ja painamalle <kbd>enter</kbd>-painiketta.
  </div>
</p>

<p>
  Toteutan vielä metodin, joka hakee tietokannasta tietyllä id:llä varustetun pelin:
</p>

<div hljs language="php" no-escape>class Game extends BaseModel{
  // ...
  public static function find($id){
    $query = DB::connection()->prepare('SELECT * FROM Game WHERE id = :id LIMIT 1');
    $query->execute(array('id' => $id));

    $row = $query->fetch();

    if($row){
      $game = new Game(array(
        'id' => $row['id'],
        'player_id' => $row['player_id'],
        'name' => $row['name'],
        'played' => $row['played'],
        'description' => $row['description'],
        'published' => $row['published'],
        'publisher' => $row['publisher'],
        'added' => $row['added']
      ));

      return $game;
    }

    return null;
  }
}</div>

<p>
  Huomasit varmasti, että annoin tällä kertaa <code>execute</code>-metodille parametrina assosiaatiolistan, jonka avulla kerrotaan, mitä muuttujia kyselyyn upotetaan. Muuttuja upotetaan kyselyyn käyttämällä kyselyn sisällä <code>:muuttujan_nimi</code>-syntaksia ja antamalla parametriksi assosiaatiolistan, joka sisältää <code>muuttujan_nimi</code>-avaimen ja sen arvon. Lisäksi käytin <code>fetchAll</code>-metodin sijaan metodia <code>fetch</code>, joka paluttaa taulukon sijaan vain yhden assiosiaatiolistan ensimmäisestä kyselyn tuottamasta rivistä. Tässä tilanteessa se on järkevää, koska kysely tuottaa aina vain yhden rivin.
</p>

<p>
  <div class="alert alert-info">
    <h4>Vinkki</h4>
    <code>DB</code>-luokka löytyy kansion <code>lib</code> tiedostosta <code>database.php</code>. Käyttämäsi staattinen <code>connection</code>-metodi palauttaa PDO-olion, jonka avulla muodostetaan tietokantayhteys.
  </div>
</p>

<p>
  Luo seuraavaksi malli jollekkin omista tietokohteistasi ja lisää sille listaus- (<code>all</code>) ja hakutoiminnot (<code>find</code>). Molemmat näistä metodeista kannattaa toteuttaa <strong><a href="http://php.net/manual/en/language.oop5.static.php" target="_blank">staattisina</a></strong>-metodeina. Hyvä paikka testata toteuttamaasi mallia on <code>HelloWorldController</code>-luokan <code>sandbox</code>-metodi, jota kutsutaan polussa <code>/hiekkalaatikko</code>. Voit kokeilla malliasi tulostamalla metodien palautusarvot esimerkiksi seuraavasti:
</p>

<div hljs language="php" no-escape>// Sisällytetään malli kontrolleriin
require 'app/models/game.php';

class HelloWorldController extends BaseController{
  // ...
  public static function sandbox(){
    $skyrim = Game::find(1);
    $games = Game::all();
    // Tämä tulostaa kaikki pelit
    echo 'Kaikki pelit: \n';
    var_dump($games);
    // Tämä tulostaa pelin id:llä 1
    echo 'Peli id:llä 1: \n';
    var_dump($skyrim);
  }
}</div>

<p>
  Siirry selaimessa sovelluksesi polkuun <code>/hiekkalaatikko</code> ja varmista, että malliluokkasi uudet metodit toimivat, kuten pitääkin. Muista sisällyttää mallisi kontrolleriin <a href="http://php.net/manual/en/function.require.php" target="_blank">require</a>-kommennolla!
</p>

<h3>2.2 Composer ja luokkien automaattinen lataaminen</h3>

<p>
  Olemme rakentamessa melko isoa sovellusta, jolloin <code>php</code>-tiedostoja kertyy melko paljon. Eikö olisi hauskaa, jos ei tarvitsisi erikseen lisätä <code>require</code>-riviä aina, kun haluat esimerkiksi käyttää malliluokkaa toisessa tiedostossa? Apuun tulee <strong><a href="https://getcomposer.org/" target="_blank">Composer</a></strong>, PHP:n riippuvuuksienhallitsija. Composer:in avulla voit määrittää, mitä riippuvuuksia sovelluksessasi on ja se asentaa ne puolestasi. Me olemme tosin enemmän kiinnostuneita Composer:in toisesta ominaisuusta, luokkien automaattisesta lataamisesta.
</p>

<p>
  Miten Composer sitten käytännössä toimii? Kurkataan aluksi projektimme juuressa sijaitsevaan <code>composer.json</code>-tiedostoon, se näyttää tältä:
</p>

<div hljs language="json" no-escape>{
  "autoload": {
    "classmap": [
      "config/database.php",
      "lib",
      "app/controllers"
    ]
  },
  "require": {
    "slim/slim": "2.*",
    "twig/twig": "~1.0"
  }
}</div>

<img src="assets/images/composer.png" class="pull-right" style="width: 200px; height: auto; margin-left: 15px; margin-bottom: 15px;">

<p>
  Kerromme tässä tiedostossa, mitä riippuvuuksia sovelluksessame on, meillä ne ovat Twig ja Slim, sekä mistä tiedostoista haluamme etsiä automaattisesti ladattavia luokkia. Olen määrittänyt <code>classmap</code>-taulukkoon, että haluan ladata automaattisesti luokat tiedostosta <code>config/database.php</code> sekä kaikista tiedostoista kansioista <code>lib</code> ja <code>app/controllers</code>. Kun alustit sovelluksesi ensimmäistä kertaa komennolla <code>bootstrap.sh</code>, Composer asennettiin projektiisi ja sen juuressa suoritetiin <code>php composer.phar install</code>. Kyseinen komento asensi sovelluksemme riippuvuudet ja lisäsi <code>vendor</code>-kansioon tiedoston <code>autoload.php</code>, joka käynnistää luokkien automaattisen lataamisen.
</p>

<p>
  Lisää seuraavaksi kaikki sovelluksesi mallit automaattisesti ladattavien luokkien joukkoon lisäämällä niiden polku, <code>app/models</code>, <code>classmap</code>-taulukkoon <code>composer.json</code>-tiedostoon. Kun polku on lisätty, tallenna ja siirrä sovelluksesi tiedostot palvelimelle. Kun suoritat <code>deploy.sh</code>-tiedoston siirtäessäsi tiedostosi palvelimelle, suoritetaan palvelimella projektisi juuressa komento <code>php composer.phar dump-autoload</code>, joka etsii automaattisesti ladattavat luokat määrittämistäsi poluista. Jos sisällytit malliluokkasi tiedoston kontrollerissa, voit nyt poistaa <code>require</code>-rivin, Composer hoitaa homman tästä eteenpäin.
</p>

<div style="clear: both"></div>

<p>
  <div class="alert alert-info">
    <h4>Vinkki</h4>
    Jos innostut käyttämään sovelluksessasi Slim:in ja Twig:in lisäksi muita PHP-kirjastoja, määritä ne vain <code>require</code>-objektissa ja suorita users-palvelimen puolella projektisi juuressa komento <code>php composer.phar update</code>. Komennon suorittaminen päivittää sovelluksesi riippuvuudet.
  </div>
</p>

<h3>2.3 SQL-injektio</h3>

<p>
  Kun upotit muuttujia tietokantakyselyysi PDO:n avulla saatoit ehkä miettiä, miksi emme vain upota muuttujia suoraan tietokantakyselyihimme? Se onnistuisi helposti näin:
</p>

<div hljs language="php" no-escape>$query = DB::connection()->prepare('SELECT * FROM Game WHERE id = ' . $id . ' LIMIT 1');
$query->execute();</div>

<p>
  Ongelma on, ettemme voi koskaan tietää, mikä <code>$id</code>-muuttujan arvo on, emme edes tiedä, onko se kokonaisluku. Pahimmassa tauksessa sen arvo on tämä:
</p>

<div hljs language="php" no-escape>$id = '1 ; DROP TABLE Game; SELECT * FROM Player';</div>

<p>
  Oops! Sinne meni tietokantataulumme.
</p>

<p>
  Kyseessä on <strong><a href="http://fi.wikipedia.org/wiki/SQL-injektio" target="_blank">SQL-injektio</a></strong>, jossa hyökkääjä pääsee suorittamaan tietokannassamme komentoja, joita hänen ei missään nimessä pitäisi pystyä suorittamaan.
  SQL-injektion vaara on aina olemassa, kun upotamme käyttäjän syöttämiä arvoja suoraan tietokantakyselyymme. Yleensä tietokantakyselyt kannattaakin suorittaa kirjastoluokkien tarjoamien palvelujen avulla, jotka hoitavat SQL-injektioiden ehkäisyn puolestasi. PHP:ssa tälläinen kirjasto on jo käyttämämme <a href="http://php.net/manual/en/book.pdo.php" target="_blank">PDO</a>.
</p>

<p>
  <img src="assets/images/sql-injektio.png">
</p>

<hr>
<a id="3-kontrollerit-ja-mallit"></a>
<h2>3. Kontrollerit ja mallit</h2>
<p>
  Kuten jo todettiin, mallit tarjoavat palveluita tietokannan muokkaamiseen ja hakuun. Käytännössä kontrolleri saattaa esimerkiksi pyytää mallilta jonkin tietokohteen oliot ja renderöi sen jälkeen näkymän, joka listaa ne. Katsomme seuraavaksi hieman tarkemmin, miten kontrollerit käyttävät malleja.
<p>

<h3>3.1 Sisältöä näkymiin</h3>
<p>
  Haluan sovellukseeni näkymän, joka listaa kaikki käyttäjän pelit. Tein sille viime viikolla jo näkymän, joka näytti tältä:
</p>
<h1>Käyttäjän Henri pelikirjasto</h1>

<p>
  <a href="#" class="btn btn-success">Lisää peli</a>
</p>

<table class="table table-striped table-bordered">
  <thead>
    <tr>
      <th>Nimi</th>
      <th>Julkaisupäivä</th>
      <th>Julkaisija</th>
      <th>Status</th>
      <th>Lisäyspäivä</th>
      <th></th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><a href="#">The Elder Scrolls V: Skyrim</a></td>
      <td>11.11.2011</td>
      <td>Bethesda Softworks</td>
      <td><label class="label label-danger">kesken</label></td>
      <td>9.12.2014</td>
      <td><a class="btn btn-default btn-sm" href="#">Muokkaa</a></td>
    </tr>
  </tbody>
</table>
<p>
  Tämä näkymä on kuitenkin vielä staattinen, eikä oikeasti listaa mitään tietokantaan talletettuja pelejä. Seuraavaksi aionkin laittaa näkymän oikeasti listaamaan tietokantaani talletetut pelit. Aloitan luomalla kansioon <code>app/controllers</code> tiedoston <code>games_controller.php</code>, jonne toteutan <code>GameController</code>-luokan, joka on sovellukseni ensimmäinen kontrolleri:
</p>

<div hljs language="php" no-escape>class GameController extends BaseController{
  // ...
}</div>

<p>
  Muista periä <code>BaseController</code>-luokka, niin pääset käyttämään sen metodeja. Lisään seuraavaksi luokkaan <code>index</code>-metodin, joka hoitaa pelien listaamisen:
</p>

<div hljs language="php" no-escape>class GameController extends BaseController{
  public static function index(){
    // Haetaan kaikki pelit tietokannasta
    $games = Game::all();
    // Renderöidään views/game kansiossa sijaitseva tiedosto index.html muuttujan $games datalla
    View::make('game/index.html', array('games' => $games));
  }
}</div>

<p>
  Katsotaanpa, mitä metodissa oikein tapahtuu. Haen siis <code>Game</code>-luokan <code>all</code>-metodin avulla kaikki pelit tietokannastani. Sen jälkeen renderöin kansiossa <code>views/game</code> sijaitsevan tiedoston <code>index.html</code>, mutta tällä kertaa välitän <code>make</code>-metodille näkymätiedoston lisäksi assosiaatiolistan, joka sisältää pelini <code>games</code>-avaimen arvona. Nyt näkymässäni on käytössä <code>games</code>-niminen taulukko tietokantani peleistä. Seuraavaksi minun täytyy muokata hieman näkymääni, jotta saan esitettyä siinä kontrollerin välittämän datan. Muokkaan <code>index.html</code> tiedoston seuraavanlaiseksi:
</p>

<div hljs language="xml" no-escape>{% extends "base.html" %}

{% block content %}
  &lt;h1>Käyttäjän Henri pelikirjasto&lt;/h1>

  &lt;p>
    &lt;a href="{{base_path}}/game/create" class="btn btn-success">Lisää peli&lt;/a>
  &lt;/p>

  &lt;table class="table table-striped table-bordered">
    &lt;thead>
      &lt;tr>
        &lt;th>Nimi&lt;/th>
        &lt;th>Julkaisupäivä&lt;/th>
        &lt;th>Julkaisija&lt;/th>
        &lt;th>Status&lt;/th>
        &lt;th>Lisäyspäivä&lt;/th>
        &lt;th>&lt;/th>
      &lt;/tr>
    &lt;/thead>

    &lt;tbody>
      {% for game in games %}
        &lt;tr>
          &lt;td>&lt;a href="{{base_path}}/game/{{game.id}}">{{game.name}}</a>&lt;/td>
          &lt;td>{{game.published}}&lt;/td>
          &lt;td>{{game.publisher}}&lt;/td>
          &lt;td>
              {% if game.played %}
                &lt;label class="label label-success">pelattu</label>
              {% else %}
                &lt;label class="label label-danger">kesken</label>
              {% endif %}
          &lt;/td>
          &lt;td>{{game.added}}&lt;/td>
          &lt;td>&lt;a class="btn btn-default btn-sm" href="{{base_path}}/game/{{game.id}}/edit">Muokkaa&lt;/a>&lt;/td>
        &lt;/tr>
      {% endfor %}
    &lt;/tbody>
  &lt;/table>
{% endblock %}</div>

<p>
  <div class="alert alert-info">
    <h4>Vinkki</h4>
    Sovelluksen näkymät kannattaa jaotella kansioihin tietokohteiden mukaan <code>app/views</code>-kansioon. Kuten huomasit lisäsin tietokohteeni <code>game</code> näkymät kansioon <code>game</code>. Tämä selkeyttää huomattavasti näkymien hallintaa.
  </div>
</p>

<p>
  <div class="alert alert-warning">
    <h4>Muistathan?</h4>
    Muista lisätä kaikkien näkymäsi polkujen eteen, kuten linkkeihin, <code>{{base_path}}</code>, muuten polut osoittavat <code>htdocs</code> kansion juureen, eivätkä oman projektikansiosi juureen.
  </div>
</p>

<p>
  Kuten huomaat, kontrollerissani välittämä <code>games</code>-muuttuja on käytössä näkymässäni. Itse näkymässä ei tapahdu mitään kovin erikoista, käyn <code>{% for game in games %}</code>-blokin sisällä läpi kaikki <code>games</code>-muuttujaan talletetut pelit, jotka annoin näkymälle. <code>for</code>-blokki muistuttaa hyvin paljon <code>foreach</code>-looppia, se tarvitsee vain iteroitavan taulukon ja nimen iteroitavalle alkiolle. Blokin sisällä upotan jokaisen pelin tiedot taulukkoon syntaksilla <code>{{muuttujan_nimi}}</code> ja teen <code>{% if game.played %}</code>-blokin avulla pienen ehtolauseen kaunistaakseni näkymääni. Twigillä voi tehdä siis vaikka mitä, lue <a href="http://twig.sensiolabs.org/doc/templates.html" target="_blank">täältä</a> lisää sen hyödyllisistä ominaisuuksista.
</p>

<p>
  Luettuasi hieman Twigistä, luo yhdelle oman sovelluksesi tietokohteelle listaus- ja esittelysivu. Pohjana kannattaa käyttää viikolla 2 tekemiäsi käyttöliittymäsuunnitelmia.
</p>

<h3>
  3.2 Dynaamiset reitit
</h3>

<p>
  Haluan pelini esittelysivun poluksi <code>game/ID</code>, jossa <code>ID</code> on näytettävän pelin id. Tämä on helppo toteuttaa käyttämällämme Slim-frameworkilla. Tässä on sovellukseni reitit tällä hetkellä:
</p>

<div hljs language="php" no-escape>// Etusivu (pelien listaussivu)
$routes->get('/', function(){
  GameController::index();
});

// Pelien listaussivu
$routes->get('/game', function(){
  GameController::index();
});

// Pelin esittelysivu
$routes->get('/game/:id', function($id){
  GameController::show($id);
});</div>

<p>
  Kuten huomaat, esittelysivun reittiin <code>/game/:id</code> on upotettu muuttuja <code>id</code>, joka on lisätty polkuun <code>:id</code>-syntaksilla. Nyt kun sovelluksessa menee esimerkiksi polkuun <code>game/1</code>, saa muuttuja arvokseen <code>1</code>. Tätä tietoa voimme käyttää kontrollerissa, hakeaksemme halutun pelin tietokannasta.
</p>

<p>
  <div class="alert alert-info">
    <h4>Vinkki</h4>
    Voit tulostaa koodin seasta viestejä PHP-logeihin <a href="http://php.net/manual/en/function.error-log.php" target="_blank">error_log</a>-funktion avulla. Muistathan, että pääset tarkkailemaan logeja suorittamalla terminaalissa projektisi juuressa komennon <code>bash php_logs.sh</code>. Logit pystyy sulkeamaan näppäilemällä terminaaliin <kbd>ctrl+c</kbd>.
  </div>
</p>

<hr>
<a id="4-lomakkeet-ja-lisaystoiminnot"></a>
<h2>4. Lomakkeet ja lisäystoiminnot</h2>

Olemme tähän asti käsitelleet, miten GET-pyynnöt kulkevat sovelluksemme läpi. Olemme tulleet kuitenkin pisteeseen, jossa haluamme ottaa vastaan syötteitä käyttäjältämme. Miten esimerkiksi käyttäjä voisi lisätä pelin kirjastoonsa?

<h3>4.1 HTTP POST-pyynnöt ja lomakkeet</h3>

<p>
  Kun kirjaudut esimerkiksi sähköpostiisi, lähetät luultavasti lomakkeen kauttaa <strong>POST-pyynnön</strong> palvelimelle, joka kertoo, millä käyttäjätunnuksella ja salasanalla yrität kirjautua sisään. Otetaan käytännön esimerkiksi pyynnöt, mitkä aiheutin, kun kirjauduin selaimellani labtooliin:
</p>

<p>
  <img src="assets/images/post-pyynto.jpg">
</p>

<p>
  Tein siis POST-pyynnön polkuun <code>/sessions</code> ja pyynnön otsakkeina selaimeni lähetti mm. kentät <code>email</code> ja <code>password</code>, joiden sisältö määräytyi täyttämäni kirjautumislomakkeen perusteella. Onnistuneen kirjautumisen jälkeen selaimeni sai palvelimelta uudelleenohjauksen statuskoodilla 302, jonka seurauksena selaimeni teki GET-pyynnön polkuun <code>/courses/8</code>. Palataan uudelleenohjauksiin pian, katsotaan vain ensin, miten lähetämme ja vastaanotamme POST-pyyntöjä sovelluksessamme.
</p>

<p>
  Voimme helposti toteuttaa näkymäämme lomakkeen, joka lähettää POST-pyynnön palvelimellemme. Minä tarvitsen sovellukseeni lomakkeen pelien lisäystä varten, joten luon tiedoston <code>new.html</code> kansioon <code>app/views/game</code>:
</p>

<div hljs language="xml">{% extends "base.html" %}

{% block content %}
  <h1>Lisää peli kirjastoosi</h1>

  <form method="post" action="{{base_path}}/game">
    <div class="form-group">
      <label>Nimi</label>
      <input type="text" name="name" class="form-control">
    </div>

    <div class="form-group">
      <label>Julkaisija</label>
      <input type="text" name="publisher" class="form-control">
    </div>

    <div class="form-group">
      <label>Julkaisupäivä</label>
      <input type="text" name="published" class="form-control">
    </div>

    <div class="form-group">
      <label>Kuvaus</label>
      <textarea name="description" class="form-control"></textarea>
    </div>

    <div class="form-group">
      <button type="submit" class="btn btn-primary">Lisää</button>
    </div>
  </form>
{% endblock %}</div>

<p>
  Lomakkeeni lähettää kenttiensä sisällöt polkuun <code>/game</code>, joka käy ilmi katsomalla <code>form</code>-tagin <code>action</code>-attribuutin arvoa. Muista lisätä polun eteen palvelimella sijaitsevan projektisi kansion nimi, joka löytyy muuttujasta <code>base_path</code>. Lisäksi lomakkeeni metodiksi on määritelty <code>post</code>, joka käy ilmi <code>method</code>-attribuutin arvosta. Metodi olisi voinut olla myös <code>get</code>.
  Olen myös määritellyt jokaiselle lomakkeeni kentälle <code>name</code>-attribuutin, jonka avulla voin myöhemmin viitata kenttään ja hakea sen arvon lomaketta käsittelevässä kontrollerissa.
</p>

<p>
  <div class="alert alert-info">
    <h4>Vinkki</h4>
    Tekstikentät eivät ole suinkaan ainoita lomakkeen elementtejä. Voit lisäksi lähettää lomakkeiden kautta esimerkiksi monivalintakenttiä ja checkboxeja. <a href="http://www.w3schools.com/html/html_form_elements.asp" target="_blank">Täältä</a> löydät listan lomakkeen elementeistä.
  </div>
</p>

<p>
  Seuraavaksi katsomme, miten pääsemme käsiksi lomakkeen lähettämiin tietoihin kontrollerissamme.
</p>

<h3>4.2 Käyttäjän syötteiden käsittely kontrollereissa</h3>

<p>
  Toteuttamani lomake lähettää POST-pyynnön polkuun <code>/game</code>. Aivan kuten GET-pyyntöjen kanssa, seuraavaksi minun täytyy kertoa sovellukseni, mille kontrollerille ja metodille POST-pyyntö polkuun <code>/game</code> tulee ohjata. Tämä on todella helppoa, lisään vain tämän reitin sovellukseni reittien joukkoon:
</p>

<div hljs language="php" no-escape>// ...
// Pelin lisääminen tietokantaan
$routes->post('/game', function(){
  GameController::store();
});

// Pelin lisäyslomakkeen näyttäminen
$routes->get('/game/new', function(){
  GameController::create();
});
// Määritetään reitti game/:id vasta tässä, jottei se mene sekaisin reitin game/new kanssa
</div>

<p>
  <div class="alert alert-warning">
    <h4>Muistathan?</h4>
    Slim valitsee määrittämistäsi reiteistä ensimmäisen, joka vastaa pyynnön polkua. Tällöin esimerkiksi pyyntö sovelluksen polkuun <code>game/new</code> saattaa mennä sekasin reitin <code>game/:id</code>-kanssa. Ongelman ratkaisu on määrittää reitti <code>game/new</code> ennen reittiä <code>game/:id</code>.
  </div>
</p>

<p>
  Eli muutamme vain metodiksi <code>post</code>, aika helppoa eikö? Käyttäjän lähettämän lomakkeen siis käsittelee <code>GameController</code>-luokan metodi <code>store</code>. Katsotaan, mitä siellä tapahtuu:
</p>

<div hljs language="php" no-escape>class GameControllers extends BaseController{
  // ...
  public static function store(){
    // POST-pyynnön muuttujat sijaitsevat $_POST nimisessä assosiaatiolistassa
    $params = $_POST;

    // Alustetaan uusi Game-luokan olion käyttäjän syöttämillä arvoilla
    $game = new Game(array(
      'name' => $params['name'],
      'description' => $params['description'],
      'publisher' => $params['publisher'],
      'published' => $params['published']
    ));

    // Kutsutaan alustamamme olion save metodia, joka tallentaa olion tietokantaan
    $game->save();

    // Ohjataan käyttäjä lisäyksen jälkeen pelin esittelysivulle
    Redirect::to('/game/' . $game->id, array('message' => 'Peli on lisätty kirjastoosi!'));
  }
}</div>


<p>
  Katsotaan, mitä toteuttamassani metodissa oikein tapahtuu. Aluksi otan POST-pyynnön mukana tulleet muuttujat talteen, jotka sisältävät käyttäjän täyttämien kenttien arvot. Ne sijaitsevat <code>$_POST</code>-muuttujassa assosiaatiolistana, jolloin esimerkiksi lomakkeen <code>description</code>-kentän sisältö on <code>$_POST['description']</code>. Assosiaatiolistan avaimet ovat siis lomakkeessa määrittämieni kenttien <code>name</code>-attribuuttien arvoja. Sen jälkeen luon <code>Game</code>-olion pyyntöön liittyvien muuttujien mukaisesti ja kutsun luomani olion metodia <code>save</code>, joka tallentaa sen tietokantaan. Metodissa ei tapahtu mitään muuta kovin kummallista, paitsi se, että se lisää olion <code>id</code>-attribuutiksi tietokantaan lisätyn rivin <code>id</code>-sarakkeen arvon. Se onnistuu seuraavasti:
</p>
<div hljs language="php" no-escape>class Game extends BaseModel{
  // Huomaathan, että save-metodi ei ole staattinen!
  public function save(){
    // Lisätään RETURNING id tietokantakyselymme loppuun, niin saamme lisätyn rivin id-sarakkeen arvon
    $query = DB::connection()->prepare('INSERT INTO Game (name, published, publisher, description) VALUES (:name, :published, :publisher, :description) RETURNING id');
    // Muistathan, että olion attribuuttiin pääse syntaksilla $this->attribuutin_nimi
    $query->execute(array('name' => $this->name, 'published' => $this->published, 'publisher' => $this->publisher, 'description' => $this->description));
    // Haetaan kyselyn tuottama rivi, joka sisältää lisätyn rivin id-sarakkeen arvon
    $row = $query->fetch();
    // Asetetaan lisätyn rivin id-sarakkeen arvo oliomme id-attribuutin arvoksi
    $this->id = $row['id'];
  }
}</div>

<p>
  Saamme siis viimeksi lisätyn rivin lisäämällä SQL-kyselyn loppuun komennon <code>RETURNIN id</code>, joka paluttaa lisätyn rivin id-sarakkeen arvon. Lisään sen arvon olioni <code>id</code>-attribuutiksi, jotta voin käyttää sitä kontrollerissani. Muistathan, että tietokantakyselyyn pystyy upottamaan muuttujilla käyttämällä tietokantakyselyssä <code>:upotettavan_muuttujan_nimi</code>-syntaksia (muista <code>:</code>-muuttujan nimen eteen!) ja antamalla <code>execute</code>-metodissa upotettavien muuttujien arvot assosiaatiolistana, jonka avaimina toimivat muuttujien nimet ja arvoina niitä vastaavat arvot. Jos tietokantakyselyiden syntaksi on päässyt unohtumaan, kannattaa virkistää muistia <strong><a href="http://www.tutorialspoint.com/postgresql/postgresql_insert_query.htm" target="_blank">INSERT INTO</a></strong>-lauseiseiden osalta.
</p>
<p>
  <code>store</code>-metodissa ei siis tapahtu mitään kovin ihmeellistä. Mutta entäs metodin viimeinen rivi <code>Redirect::to(...)</code>? Se on jotain aivan uutta, mitä ihmettä siinä tapahtuu?
</p>
<h3>4.3 Post/Redirect/Get - PRG</h3>

<img src="assets/images/302.jpg" class="pull-left" style="width: 350px; height: auto; margin-right: 15px; margin-bottom: 15px;">
<p>
  <a href="http://en.wikipedia.org/wiki/Post/Redirect/Get" target="_blank"><strong>Post/Redirect/Get</strong></a> on web-sovelluksien toteutuksessa käytetty suunnittelumalli, joka estää käyttäjää vahingossa lähettämästä samaa lomaketta kahdesti. Siinä käyttäjän lähettämän POST-pyynnön jälkeen selaimelle lähetetään <strong>uudelleenohjauspyyntö</strong> statuskoodilla 302, joka pyytää selainta tekemään GET-pyynnön muualle, kuten esimerkiksi polkuun <code>/game/1</code>.
</p>

<p>
  Kuvitellaan hetki, ettei koko suunnittelumallia olisi olemassakaan, eli emme ohjaisi käyttäjää polkuun <code>/game/ID</code> pelin lisäämisen jälkeen, vaan renderöisimme näkymän <code>game/show.html</code>. Ongelmana on, että vaikka renderöimme näkymän <code>game/show.html</code>, olemme silti polussa <code>/game</code>, joka on lomakkeen kohdepolku. Jos käyttäjä nyt päivittää selaimessaan sivun, lisäyslomake lähetetään uudestaan, vaikka käyttäjä luuli päivittävänsä pelin esittelysivun. Sitä emme halua.
</p>

<p>
  Ohjaamme siis käyttäjän POST-pyynnön jälkeen toiselle sivulle kutsumalla <code>Redirect</code>-luokan metodia <code>to</code>. Parametreikseen metodi ottaa tietenkin polun, mihin käyttäjä ohjataan, mutta lisäksi voit halutessasi antaa toiseksi parametriksi assosiaatiolistan, jonka sisältö voidaan esittää kohdenäkymässä, esimerkiksi pelin esittelysivulla:
</p>
<div style="clear: both"></div>

<div hljs language="xml"><!-- ... -->
<!-- Näkymä games/show.html -->
<div class="alert alert-success">
  {{message}}
</div>
<!-- ... -->
</div>

<p>
  <div class="alert alert-success">
    Peli on lisätty kirjastoosi!
  </div>
</p>

<p>
  Luokan <code>Redirect</code> metodin <code>to</code> toteutus on melko yksinkertainen, se käyttää vain <a href="http://php.net/manual/en/function.header.php" target="_blank">header</a>-funktiota lähettämään selaimelle uudelleenohjauspyynnön seuraavasti:
</p>

<div hljs language="php" no-escape>header('Location: ' . $polku);
// Lopetetaan koodin suorittaminen uudelleenohjauksen jälkeen exit-funktiota kutsumalla
exit();
</div>

<p>
  Toisena parametrina annetun viestin lähettäminen kohteena olevaan näkymään taas tapahtuu <a href="http://www.w3schools.com/php/php_sessions.asp" target="_blank">session</a>-avulla. Puhumme sessioista lisää ensi viikolla. <code>to</code>-metodin toteutukseen voi tutustua tarkemmin kurkkaamalla <code>lib/redirect.php</code>-tiedostoa.
</p>
<hr>
<a id="5-palautuksen-vaatimukset"></a>
<h2>5. Palautuksen vaatimukset</h2>
<ol>
  <li>Toteuta sovellukseesi vähintään yksi malliluokka, jossa on kaikki tietokohteen oliot tietokannasta hakeva metodi (esim. <code>all</code>), tietyllä id:llä varustetun tietokohteen olion tietokannasta hakeva metodi (esim. <code>find</code>) ja tietokohteen olion tietokantaan lisäävä metodi (esim. <code>save</code>). <strong>(1,5p)</strong></li>
  <li>Toteuta malliasi käyttämään kontrolleriin metodit, jotka esittävät tietokohteen listaus-, esittely- ja lisäysnäkymän. Toteuta myös kontrolleriisi metodi, joka mahdollistaa tietokohteen olion lisäämisen tietokantaan käyttäjän lähettämän lomakkeen tiedoilla. <strong>(1,5p)</strong></li>
  <li>Kirjoita <a href="http://advancedkittenry.github.io/aikataulu/koodikatselmointi.html" target="_blank">koodikatselmointi</a> (vapaaehtoinen). <strong>(0-2p)</strong></li>
  <li>
    <strong>Pushaa kaikki tekämäsi muutokset repoosi!</strong>
  </li>
</ol>
<a href="#viikko4" class="btn btn-default pull-right">Viikko 4 <span class="glyphicon glyphicon-chevron-right"></span></a>
