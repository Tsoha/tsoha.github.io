<div class="page-header">
  <h1>Viikko 3</h1>
</div>
<h2>Sisällysluettelo</h2>
<ul class="nav nav-pills nav-stacked">
  <li><a href="" ng-click="goto_anchor('1-php-haltuun')">1. PHP haltuun</a></li>
  <li><a href="" ng-click="goto_anchor('2-mallit')">2. Mallit</a></li>
  <li><a href="" ng-click="goto_anchor('3-kontrollerit-ja-mallit')">3. Kontrollerit ja mallit</a></li>
  <li><a href="" ng-click="goto_anchor('4-lomakkeet-ja-lisaystoiminnot')">4. Lomakkeet ja lisäystoiminnot</a></li>
  <li><a href="" ng-click="goto_anchor('5-palautuksen-vaatimukset')">5. Palautuksen vaatimukset</a></li>
</ul>

<hr>
<a id="1-php-haltuun"></a>
<h2>1. PHP haltuun</h2>
<p>
  Ennen kuin etenemme sovelluksemme toteutuksessa pidemmälle, sukelletaan hetkeksi PHP:n saloihin.
</p>
<h3>1.1 Muuttujat</h3>
<p>
  Kuten jo ensimmäisellä viikolla tuli esille, PHP:ssa muuttujilla ei ole tyyppiä, vaan kaikkia muuttujat määritellään ja niihin viitataan <code>$</code>-merkillä. Voimme siis tallentaa muuttujiin kokonaislukuja, merkkijonoja, taulukoita ja muita otuksia ottamatta kantaa muuttujaan tyyppiin. Voimme myös vapaasti tallettaa muuttujaan ensin toisen tyyppisen muuttujan ja sen jälkeen korvata sen toisen tyyppisellä muuttujalla. Tässä pieni esimerkki muuttujista:
</p>
<div hljs no-escape>
// muuttuja on merkkijono
$kalle = 'Kalle';
// ei ole enää, muhahah!
$kalle = 22;
// muuttuja voi olla taulukko...
$taulukko = array('Kalle', 'Elina');
// ..tai olio...
$jamppa = new Henkilo('Jamppa');
// ...tai funktio
$laske = function($operaatio, $eka, $toka){
  return $operaatio($eka, $toka);
}
</div>
<h3>1.2 Taulukot ja assosiaatiolistat</h3>
<p>
  PHP:n luultavasti tärkein tietorakenne on <strong>taulukko</strong> (<code>array</code>), joka on kokoelma otuksia, kuten merkkijonoja, kokonaislukuja, tai toisia taulukoita. Koska PHP on tyypitön, voi taulukko koostua erityyppisistä arvoista, vaikkakin se voi olla hieman sekavaa. Taulukon alustaminen on helppoa, tässä on esimerkki taulukosta merkkijonoja:
</p>

<div hljs no-escape>$kaverit = array('Henri', 'Elina', 'Riku', 'Viivi', 'Jorma', 'Teo');</div>

<p>
  Nyt <code>$kaverit</code>-muuttujassa on taulukko, jossa on kuusi merkkijonoa. Katsotaan, mitä voimme saada irti tästä taulukosta:
</p>

<div hljs no-escape>echo 'Kallen esimmäinen kaveri on:\n';
echo $kaverit[0] . '\n';
// Henri
echo 'Kallen viimeinen kaveri on:\n';
echo $kaverit[5] . '\n';
// Teo
echo 'Kallen kavereita ovat:\n'
foreach($kaverit as $kaveri){
  echo $kaveri . '\n';
  // Tähän tulostuu kaverin nimi
}
// Lisätään Kallelle kaveri
$kaverit[] = 'Helena';
echo 'Kallen viimeinen kaveri on:\n';
echo $kaverit[6] . '\n';
// Helena
echo 'Kallella on yhteensä ' . count($kaverit) . ' kaveria';
// Kallella on yhteensä 7 kaveria
</div>

<p>
  Merkkijonon alkioihin voi siis Javan tapaan viitata indeksillä, jolloin esimmäinen alkio on indeksissä 0. <code>$kaverit[0]</code> on siis taulukon ensimmäinen alkio. Taulukon läpikäyntiin voi käyttää <code>foreach</code>-looppia, johon annetaan iteroitava taulukko ja iteroitavan alkion nimi. Iteroitavaan alkioon voi viitata loopin sisällä, jolloin esimerkissä tulostuu kaikki taulukon alkiot.
</p>

<p>
  Taulukkoon voi myös helposti lisätä alkioita. Se tapahtuu esimerkissä kohdassa <code>$kaverit[] = 'Helena'</code>. Alkion lisääminen taulukkoon onnistuu myös <a href="http://php.net/manual/en/function.array-push.php" target="_blank">array_push</a>-funktion avulla, jolloin esimerkissä alkion <code>'Helena'</code> voisi lisätä taulukkoon <code>$kaverit</code> kutsulla <code>array_push($kaverit, 'Helena')</code>. Toinen hyödyllinen taulukkoihin liittyvä funktio on <a href="http://php.net/manual/en/function.count.php" target="_blank">count</a>, joka palauttaa taulukon alkioiden lukumäärän.
</p>

<p>
  Toinen erittäin tärkeä tietorakenne on <strong>assosiaatiolista</strong>, joka muistuttaa Javan HashMap:ia. Assosiaatiolista koostuu avain-arvo-pareista, joka esitetään seuraavasti:
</p>

<div hljs no-escape>$iat = array(
  'kalle' => 22,
  'elina' => 24,
  'henri' => 21
);</div>

<p>
  <code>$iat</code>-assosiaatiolistassa on avaimet <code>kalle</code>, <code>elina</code> ja <code>henri</code> ja niitä vastaavat arvot <code>22</code>, <code>24</code>, <code>21</code>. <strong>Assosiaatiolistan avaimen täytyy aina olla merkkijono</strong>. Katsotaan, miten voimme käsitellä assosiaatiolistoja:
</p>

<div hljs no-escape>echo 'Kalle on ' . $iat['kalle'] . ' vuotta vanha\n';
// Kalle on 22 vuotta vanha
echo 'Elina on ' . $iat['elina'] . ' vuotta vanha\n';
// Elina on 24 vuotta vanha
echo 'Henri on ' . $iat['henri'] . ' vuotta vanha\n';
// Henri on 21 vuotta vanha
// Kallella on syntymäpäivät, vaihdetaan hänen ikänsä
$iat['kalle'] = 23;
echo 'Kalle on ' . $iat['kalle'] . ' vuotta vanha\n';
// Kalle on 23 vuotta vanha</div>

<p>
  Kuten esimerkistä näkee, assosiaatiolistan avainta vastaavan arvon saa syntaksilla <code>$lista['avain']</code>, jolloin avaimen <code>kalle</code> arvo esimerkissä <code>$iat['kalle']</code>. Avaimen arvoa voi myös muuttaa, kuten esimerkissä avaimen <code>kalle</code> arvoksi asetettiin <code>23</code>, kohdassa <code>$iat['kalle'] = 23</code>.
</p>

<h3>1.3 Luokat</h3>

<p>
  Katsotaan seuraavaksi lyhyesti, miten Javasta tutut <strong>luokat</strong> toteutetaan PHP:ssa. Tässä on esimerkki luokasta <code>Koira</code>:
</p>

<div hljs no-escape>class Koira{
  // attribuutit
  public $nimi, $omistaja, $paino, $ika;
  // konstruktori
  public function __construct($nimi, $omistaja, $paino, $ika){
    $this->nimi = $nimi;
    $this->omistaja = $omistaja;
    $this->paino = $paino;
    $this->ika = $ika;
  }
  // olioon liittyvä julkinen metodi
  public function hauku(){
    $sanonta = $this->mita_koira_sanoo();
    return $this->nimi . ': ' . $sanonta;
  }
  // luokkaan liittyvä staattinen metodi
  public static function eliokunta(){
    return 'Nisäkkäät';
  }
  // olioon liittyvä privaatti metodi
  private function mita_koira_sanoo(){
    return 'Hau, hau!';
  }
}</div>

<p>
  Esimerkissä <code>Koira</code>-luokkaan liittyy neljä attribuuttia - <code>$nimi</code>, <code>$omistaja</code>, <code>$paino</code> ja <code>$ika</code>. Attribuuttien näkyvyysalueeksi on asetettu <code>public</code>, joten niihin pääsee käsiksi kaikkialta, myös luokan ulkopuolelta. Luokan konstruktori määritetään metodissa <code>__construct</code>, joka ottaa parametreikseen kaikki koiraan liittyvät tiedot. Olion attribuutteihin pystyy viittaamaan syntaksilla <code>$this->attribuutin_nimi</code>, jolloin esimerkissä nimi attribuutin arvo on <code>$this->nimi</code>.
</p>

<p>
  Luokalla voi olla sen olioon liittyviä metodeja, tai itse luokkaan liittyviä metodeja, eli staattisia metodeja (<code>static</code>). <code>Koira</code>-luokalle on määritelty oliometodit <code>hauku</code> ja <code>mita_koira_sanoo</code> sekä staattinen metodi <code>eliokunta</code>. Tässä pieni esimerkki <code>Koira</code>-luokan käytöstä:
</p>

<div hljs no-escape>$rekku = new Koira('Rekku', 'Kalle', 10, 2);
echo $rekku->nimi;
// Rekku
echo $rekku->hauku();
// Rekku: Hau, hau!
echo Koira::eliokunta();
// Nisäkkäät</div>

<p>
  <div class="alert alert-info">
    <h4>Vinkki</h4>
    <a href="http://phpfiddle.org/" target="_blank">PhpFiddle</a> on hyvä paikka kokeilla yllä esitettyjä esimerkkejä, tai omia koodinpätkiä. Jos innostuit PHP:n opiskelusta, löytyy <a href="http://www.w3schools.com/php/" target="_blank">W3Schools</a>:ista läjäpäin hyviä PHP-tutoriaaleja.
  </div>
</p>
<hr>
<a id="2-mallit"></a>
<h2>2. Mallit</h2>

<p>
  Palataan taas ensimmäisellä viikolla esitettyyn esimerkkiin ja muistellaan, mitä siinä puhuttiin malleista:
</p>

<blockquote>
  <ol>
    <li>...</li>
    <li>...</li>
    <li>Kun kontrolleri ja metodi löytyy, sitä kutsutaan. Kontrolleri pyytää kurssien hallinnasta vastuussa olevalta mallilta kaikki tämän vuosineljänneksen kurssit.</li>
    <li>Kurssien hallinnasta vastuussa oleva malli hakee tietokannasta kaikki vuosineljänneksen kurssit, muodostaa niistä sovelluksen olioita ja palauttaa ne kontrollerille.</li>
    <li>Saatuaan haluamansa kurssit, kontrolleri pyytää kurssien listaa muodostavaa näkymää renderöimään itseensä mallilta haetuilla kursseilla...</li>
  </ol>
</blockquote>

Malli siis edustaa jotain sovelluksen tietokohdetta, kuten esimerkissämme, kurssia ja tarjoaa kontrollereille tietokannan muokkaamiseen ja hakuun liittyviä palveluita.

<h3>2.1 Oman sovelluksemme mallit</h3>

<p>
  Katsotaan seuraavaksi, miten mallit käytännössä toteutetaan. Omassa sovelluksessani minun täytyy jotenkin suorittaa peleihin liittyviä tietokantaoperaatiota. Tarvitsen siis pelille mallin. Lisään <code>app/models</code>-kansioon tiedoston <code>game.php</code>, johon toteutan malliluokkani. Tässä on <code>Game</code>-luokan runko:
</p>
<div hljs language="php" no-escape>class Game extends BaseModel{
    // ...
}</div>

<p>
  <div class="alert alert-warning">
    <h4>Muistathan?</h4>
    Muista lisätä jokaisen luomasi <code>php</code>-tiedoston alkuun rivi <code>&lt;?php</code>.
  </div>
</p>

<p>
  Muista periä luokka <code>BaseModel</code>, niin pääset käyttämään sen tarjoamia metodeja. Lisään seuraavaksi peliin liittyvät attribuutit ja luokalleni konstruktorin:
</p>

<div hljs language="php" no-escape>class Game extends BaseModel{
  // Attribuutit
  public $id, $player_id, $name, $played, $description, $published, $publisher, $added;
  // Konstruktori
  public function __construct($attributes){
    parent::__construct($attributes);
  }
}</div>

<p>
  <code>__construct</code>-metodi on siis luokkani <a href="http://php.net/manual/en/language.oop5.decon.php" target="_blank">konstruktori</a>. Kutsun siinä yläluokan konstruktoria, jonka avulla voin alustaa olion seuraavasti:
</p>

<div hljs language="php" no-escape>$skyrim = new Game(array('id' => 1, 'name' => 'The Elder Scrolls V: Skyrim', 'description' => 'Arrow to the knee'));</div>

<p>
  Tämä konstruktori on monella tapaa kätevämpi kuin tavanomainen, mm. sen takia, ettei ole väliä, missä järjestyksessä parametrit antaa, tai antaako niitä ollenkaan. Voin siis asettaa haluamani attribuutit antamalla konstruktorille <a href="http://php.net/manual/en/language.types.array.php" target="_blank">assosiaatiolistan</a>, joka sisältää avain-arvo-pareja. Pääset assosiaatiolistassa avaimen arvoon syntaksilla <code>$lista['avain']</code>. Voit halutessasi luoda myös erilaisen konstruktorin. Pääsemme nyt käsiksi luomamme olion attribuutteihin <code>-></code>-syntaksilla:
</p>

<div hljs language="php" no-escape>echo $skyrim->name;
// The Elder Scrolls V: Skyrim</div>

<p>
  Jos haluat päästä käsiksi attribuutteihin luokan sisällä, onnistuu se <code>$this->attribuutin_nimi</code>-syntaksilla, jolloin esimerkin <code>name</code>-attribuutin arvo on <code>$this->name</code>. Yläluokan konstruktorin toteutus löytyy tiedostosta <code>lib/base_model.php</code>.
</p>

<p>
  Minun täytyy seuraavaksi toteuttaa metodi, joka hakee kaikki pelit tietokannasta ja palauttaa ne <code>Game</code>-olioina. Sen ei pitäisi olla vaikeaa, minun täytyy tehdä vain <code>SELECT * FROM Game</code> kysely tietokantaani ja käydä läpi sen tuottamat rivit. Katsotaan, miten tämä käytännössä tapahtuu:
</p>

<div hljs language="php" no-escape copy-paste-warning>class Game extends BaseModel{
  // ...
  public static function all(){
    // Alustetaan kysely tietokantayhteydellämme
    $query = DB::connection()->prepare('SELECT * FROM Game');
    // Suoritetaan kysely
    $query->execute();

    // Haetaan kyselyn tuottamat rivit
    $rows = $query->fetchAll();
    $games = array();

    // Käydään kyselyn tuottamat rivit läpi
    foreach($rows as $row){
      // Tämä on PHP:n hassu syntaksi alkion lisäämiseksi taulukkoon :)
      $games[] = new Game(array(
        'id' => $row['id'],
        'player_id' => $row['player_id'],
        'name' => $row['name'],
        'played' => $row['played'],
        'description' => $row['description'],
        'published' => $row['published'],
        'publisher' => $row['publisher'],
        'added' => $row['added']
      ));
    }

    return $games;
  }
}</div>
<p>
  <div class="alert alert-warning">
    <h4>Muistathan?</h4>
    Olet varmasti huomannut, että kommentoin koodiani esimerkeissä melko paljon. Teen sen vain sen vuoksi, että ymmärtäisit esimerkkejä paremmin. Omaa koodiasi sinun ei tarvitse kommentoida juuri lainkaan, ellei jokin kohta ole erityisen epäselvä.
  </div>
</p>
<p>
  Käydäänpä läpi, mitä metodissa tapahtuu. Määrittelen aluksi staattisen metodin <code>all</code> ja kutsun <code>DB</code>-luokan staattista metodia <code>connection</code>, joka palauttaa <strong><a href="http://php.net/manual/en/book.pdo.php" target="_blank">PDO</a></strong>-tietokantakirjaston tarjoaman PDO-yhteysolion. Alustan tietokantakyselyn kutsumalla PDO-yhteysolion metodia <code>prepare</code>, joka ottaa parametrikseen suoritettavan tietokantakyselyn. Seuraavalla rivillä suoritan kyselyni kutsumalla <code>execute</code>-metodia. Kyselyn suorittamisen jälkeen kyselyn tuottamiin riveihin pääsee käsiksi kutsumalla <code>fetchAll</code>-metodia, joka palauttaa rivit taulukkona assosiaatiolistoja, jonka avaimina toimivat sarakkeiden nimet ja arvoina niiden sisältö. Käyn rivit läpi <code>foreach</code>-loopissa ja luon jokaisen rivin arvoista <code>Game</code>-olion, jonka lisään <code>games</code>-taulukkoon.
</p>

<p>
  <div class="alert alert-info">
    <h4>Vinkki</h4>
    Tietokantakyselyitä kannattaa kokeilla <code>psql</code>-komentotulkissa ennen kuin käytät niitä malleissa, jotta voit olla varma, että ne toimivat haluamallasi tavalla. Muistathan, että pääset käyttämään komentotulkkia ottamalla SSH-yhteyden users-palvelimeen komennolla <code>ssh kayttajatunnus@users.cs.helsinki.fi</code> (korvaa kohta <code>kayttajatunnus</code> omalla CS-käyttäjätunnuksellasi) ja suorittamalla users-palvelimen puolella komennon <code>psql</code>. Kun testaamasi tietokantakysely toimii, voit sulkea komentotulkin syöttämällä <code>\q</code> ja painamalle <kbd>enter</kbd>-painiketta.
  </div>
</p>

<p>
  Toteutan vielä metodin, joka hakee tietokannasta tietyllä id:llä varustetun pelin:
</p>

<div hljs language="php" no-escape copy-paste-warning>class Game extends BaseModel{
  // ...
  public static function find($id){
    $query = DB::connection()->prepare('SELECT * FROM Game WHERE id = :id LIMIT 1');
    $query->execute(array('id' => $id));

    $row = $query->fetch();

    if($row){
      $game = new Game(array(
        'id' => $row['id'],
        'player_id' => $row['player_id'],
        'name' => $row['name'],
        'played' => $row['played'],
        'description' => $row['description'],
        'published' => $row['published'],
        'publisher' => $row['publisher'],
        'added' => $row['added']
      ));

      return $game;
    }

    return null;
  }
}</div>

<p>
  Huomasit varmasti, että annoin tällä kertaa <code>execute</code>-metodille parametrina assosiaatiolistan, jonka avulla kerrotaan, mitä muuttujia kyselyyn upotetaan. Muuttuja upotetaan kyselyyn käyttämällä kyselyn sisällä <code>:muuttujan_nimi</code>-syntaksia ja antamalla parametriksi assosiaatiolistan, joka sisältää <code>muuttujan_nimi</code>-avaimen ja sen arvon. Lisäksi käytin <code>fetchAll</code>-metodin sijaan metodia <code>fetch</code>, joka paluttaa taulukon sijaan vain yhden assiosiaatiolistan ensimmäisestä kyselyn tuottamasta rivistä. Tässä tilanteessa se on järkevää, koska kysely tuottaa aina vain yhden rivin. Edit: jos käyttää tietokantaoliossa boolean-arvoja saattaa execute(assosiaatiolista) bugata käyttämässämme PHP-versiossa. Tällöin on parempi käyttää bindValueta <a href="http://pastebin.com/n7B7NBtd">linkki</a>.
</p>

<p>
  <div class="alert alert-info">
    <h4>Vinkki</h4>
    <code>DB</code>-luokka löytyy kansion <code>lib</code> tiedostosta <code>database.php</code>. Käyttämäsi staattinen <code>connection</code>-metodi palauttaa PDO-olion, jonka avulla muodostetaan tietokantayhteys.
  </div>
</p>

<h3>2.2 Malliluokan testaaminen ja debuggaamisen alkeet</h3>

<p>
  Tsoha Bootstrappiin on valmiiksi asennettu näppärä debuggauskirjasto, <strong><a href="https://kint-php.github.io/kint/" target="_blank">Kint</a></strong>. Sen avulla voit tulostaa muuttujien arvoja koodin seasta, sekä jäljittää koodin suoritusta. Katsotaan Kintin avulla, mitä arvoja malliluokkaamme toteuttamamme metodit <code>all</code> ja <code>find</code> palauttavat lisäämälle <code>HelloWorldController</code>-luokan metodiin <code>sandbox</code> seuraavat debuggausviestit:
</p>

<div hljs language="php" no-escape>// Muista sisällyttää malliluokka require-komennolla!
require 'app/models/game.php';

class HelloWorldController extends BaseController{
  // ...
  public static function sandbox(){
    $skyrim = Game::find(1);
    $games = Game::all();
    // Kint-luokan dump-metodi tulostaa muuttujan arvon
    Kint::dump($games);
    Kint::dump($skyrim);
  }
}</div>

<p>
  Pystyt lisäämään sivulle debuggausviestin kutsumalla <code>Kint</code>-luokan metodia <code>dump</code>, joka ottaa parametrikseen tarkasteltavan muuttujan.
</p>

<p>
  Siirry selaimessa sovelluksesi polkuun <code>/hiekkalaatikko</code> ja varmista, että malliluokkasi uudet metodit toimivat, kuten pitääkin. Sivulle pitäisi ilmestyä siniset palkit, jotka sisältävät debuggausviestisi. "+"-ikonin painaminen avaa viestin sisällön.
</p>

<p>
  Luo seuraavaksi malli jollekin omista tietokohteistasi ja lisää sille listaus- (<code>all</code>) ja hakutoiminnot (<code>find</code>). Molemmat näistä metodeista kannattaa toteuttaa <strong><a href="http://php.net/manual/en/language.oop5.static.php" target="_blank">staattisina</a></strong>-metodeina.
</p>

<h3>2.3 Composer ja luokkien automaattinen lataaminen</h3>

<p>
  Olemme rakentamassa melko isoa sovellusta, jolloin <code>php</code>-tiedostoja kertyy melko paljon. Eikö olisi hauskaa, jos ei tarvitsisi erikseen lisätä <code>require</code>-riviä aina, kun haluat esimerkiksi käyttää malliluokkaa toisessa tiedostossa? Apuun tulee <strong><a href="https://getcomposer.org/" target="_blank">Composer</a></strong>, PHP:n riippuvuuksienhallitsija. Composer:in avulla voit määrittää, mitä riippuvuuksia sovelluksessasi on ja se asentaa ne puolestasi. Me olemme tosin enemmän kiinnostuneita Composer:in toisesta ominaisuusta, luokkien automaattisesta lataamisesta.
</p>

<p>
  Miten Composer sitten käytännössä toimii? Kurkataan aluksi projektimme juuressa sijaitsevaan <code>composer.json</code>-tiedostoon, se näyttää tältä:
</p>

<div hljs language="json" no-escape>{
  "autoload": {
    "classmap": [
      "config/database.php",
      "lib",
      "app/controllers"
    ]
  },
  "require": {
    "slim/slim": "2.*",
    "twig/twig": "~1.5",
    "raveren/kint": "v0.9"
  }
}</div>

<img src="assets/images/composer.png" class="pull-right" style="width: 200px; height: auto; margin-left: 15px; margin-bottom: 15px;">

<p>
  Kerromme tässä tiedostossa, mitä riippuvuuksia sovelluksessamme on, meillä ne ovat Slim, Twig ja Kint sekä mistä tiedostoista haluamme etsiä automaattisesti ladattavia luokkia. Olen määrittänyt <code>classmap</code>-taulukkoon, että haluan ladata automaattisesti luokat tiedostosta <code>config/database.php</code> sekä kaikista tiedostoista kansioista <code>lib</code> ja <code>app/controllers</code>. Kun alustit sovelluksesi ensimmäistä kertaa komennolla <code>bootstrap.sh</code>, Composer asennettiin projektiisi ja sen juuressa suoritetiin <code>php composer.phar install</code>. Kyseinen komento asensi sovelluksemme riippuvuudet ja lisäsi <code>vendor</code>-kansioon tiedoston <code>autoload.php</code>, joka käynnistää luokkien automaattisen lataamisen.
</p>

<p>
  Lisää seuraavaksi kaikki sovelluksesi mallit automaattisesti ladattavien luokkien joukkoon lisäämällä niiden polku, <code>app/models</code>, <code>classmap</code>-taulukkoon <code>composer.json</code>-tiedostoon. Kun polku on lisätty, tallenna ja siirrä sovelluksesi tiedostot palvelimelle. Kun suoritat <code>deploy.sh</code>-tiedoston siirtäessäsi tiedostosi palvelimelle, suoritetaan palvelimella projektisi juuressa komento <code>php composer.phar dump-autoload</code>, joka etsii automaattisesti ladattavat luokat määrittämistäsi poluista. Jos sisällytit malliluokkasi tiedoston kontrollerissa, voit nyt poistaa <code>require</code>-rivin, Composer hoitaa homman tästä eteenpäin.
</p>

<div style="clear: both"></div>

<p>
  <div class="alert alert-info">
    <h4>Vinkki</h4>
    Jos innostut käyttämään sovelluksessasi Slim:in, Twig:in ja Kint:in lisäksi muita PHP-kirjastoja, määritä ne vain <code>require</code>-objektissa ja suorita users-palvelimen puolella projektisi juuressa komento <code>php composer.phar update</code>. Komennon suorittaminen päivittää sovelluksesi riippuvuudet.
  </div>
</p>

<h3>2.4 SQL-injektio</h3>

<p>
  Kun upotit muuttujia tietokantakyselyysi PDO:n avulla saatoit ehkä miettiä, miksi emme vain upota muuttujia suoraan tietokantakyselyihimme? Se onnistuisi helposti näin:
</p>

<div hljs language="php" no-escape>$query = DB::connection()->prepare('SELECT * FROM Game WHERE id = ' . $id . ' LIMIT 1');
$query->execute();</div>

<p>
  Ongelma on, ettemme voi koskaan tietää, mikä <code>$id</code>-muuttujan arvo on, emme edes tiedä, onko se kokonaisluku. Pahimmassa tapauksessa sen arvo on tämä:
</p>

<div hljs language="php" no-escape>$id = '1 ; DROP TABLE Game; SELECT * FROM Player';</div>

<p>
  Oops! Sinne meni tietokantataulumme.
</p>

<p>
  Kyseessä on <strong><a href="http://fi.wikipedia.org/wiki/SQL-injektio" target="_blank">SQL-injektio</a></strong>, jossa hyökkääjä pääsee suorittamaan tietokannassamme komentoja, joita hänen ei missään nimessä pitäisi pystyä suorittamaan.
  SQL-injektion vaara on aina olemassa, kun upotamme käyttäjän syöttämiä arvoja suoraan tietokantakyselyymme. Yleensä tietokantakyselyt kannattaakin suorittaa kirjastoluokkien tarjoamien palvelujen avulla, jotka hoitavat SQL-injektioiden ehkäisyn puolestasi. PHP:ssa tälläinen kirjasto on jo käyttämämme <a href="http://php.net/manual/en/book.pdo.php" target="_blank">PDO</a>.
</p>

<p>
  <a href="https://xkcd.com/license.html"><img src="assets/images/sql-injektio.png" alt="Little Bobby Tables"></a>
</p>

<hr>
<a id="3-kontrollerit-ja-mallit"></a>
<h2>3. Kontrollerit ja mallit</h2>
<p>
  Kuten jo todettiin, mallit tarjoavat palveluita tietokannan muokkaamiseen ja hakuun. Käytännössä kontrolleri saattaa esimerkiksi pyytää mallilta jonkin tietokohteen oliot ja renderöi sen jälkeen näkymän, joka listaa ne. Katsomme seuraavaksi hieman tarkemmin, miten kontrollerit käyttävät malleja.
<p>

<h3>3.1 Sisältöä näkymiin</h3>
<p>
  Haluan sovellukseeni näkymän, joka listaa kaikki käyttäjän pelit. Tein sille viime viikolla jo näkymän, joka näytti tältä:
</p>
<h1>Käyttäjän Henri pelikirjasto</h1>

<p>
  <a href="#" class="btn btn-success">Lisää peli</a>
</p>

<table class="table table-striped table-bordered">
  <thead>
    <tr>
      <th>Nimi</th>
      <th>Julkaisupäivä</th>
      <th>Julkaisija</th>
      <th>Status</th>
      <th>Lisäyspäivä</th>
      <th></th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><a href="#">The Elder Scrolls V: Skyrim</a></td>
      <td>11.11.2011</td>
      <td>Bethesda Softworks</td>
      <td><label class="label label-danger">kesken</label></td>
      <td>9.12.2014</td>
      <td><a class="btn btn-default btn-sm" href="#">Muokkaa</a></td>
    </tr>
  </tbody>
</table>
<p>
  Tämä näkymä on kuitenkin vielä staattinen, eikä oikeasti listaa mitään tietokantaan talletettuja pelejä. Seuraavaksi aionkin laittaa näkymän oikeasti listaamaan tietokantaani talletetut pelit. Aloitan luomalla kansioon <code>app/controllers</code> tiedoston <code>games_controller.php</code>, jonne toteutan <code>GameController</code>-luokan, joka on sovellukseni ensimmäinen kontrolleri:
</p>

<div hljs language="php" no-escape>class GameController extends BaseController{
  // ...
}</div>

<p>
  Muista periä <code>BaseController</code>-luokka, niin pääset käyttämään sen metodeja. Lisään seuraavaksi luokkaan <code>index</code>-metodin, joka hoitaa pelien listaamisen:
</p>

<div hljs language="php" no-escape>class GameController extends BaseController{
  public static function index(){
    // Haetaan kaikki pelit tietokannasta
    $games = Game::all();
    // Renderöidään views/game kansiossa sijaitseva tiedosto index.html muuttujan $games datalla
    View::make('game/index.html', array('games' => $games));
  }
}</div>

<p>
  Katsotaanpa, mitä metodissa oikein tapahtuu. Haen siis <code>Game</code>-luokan <code>all</code>-metodin avulla kaikki pelit tietokannastani. Sen jälkeen renderöin kansiossa <code>views/game</code> sijaitsevan tiedoston <code>index.html</code>, mutta tällä kertaa välitän <code>make</code>-metodille näkymätiedoston lisäksi assosiaatiolistan, joka sisältää pelini <code>games</code>-avaimen arvona. Nyt näkymässäni on käytössä <code>games</code>-niminen taulukko tietokantani peleistä. Seuraavaksi minun täytyy muokata hieman näkymääni, jotta saan esitettyä siinä kontrollerin välittämän datan. Muokkaan <code>index.html</code> tiedoston seuraavanlaiseksi:
</p>

<div hljs language="xml" no-escape>{% extends "base.html" %}

{% block content %}
  &lt;h1>Käyttäjän Henri pelikirjasto&lt;/h1>

  &lt;p>
    &lt;a href="{{base_path}}/game/new" class="btn btn-success">Lisää peli&lt;/a>
  &lt;/p>

  &lt;table class="table table-striped table-bordered">
    &lt;thead>
      &lt;tr>
        &lt;th>Nimi&lt;/th>
        &lt;th>Julkaisupäivä&lt;/th>
        &lt;th>Julkaisija&lt;/th>
        &lt;th>Status&lt;/th>
        &lt;th>Lisäyspäivä&lt;/th>
        &lt;th>&lt;/th>
      &lt;/tr>
    &lt;/thead>

    &lt;tbody>
      {% for game in games %}
        &lt;tr>
          &lt;td>&lt;a href="{{base_path}}/game/{{game.id}}">{{game.name}}</a>&lt;/td>
          &lt;td>{{game.published}}&lt;/td>
          &lt;td>{{game.publisher}}&lt;/td>
          &lt;td>
              {% if game.played %}
                &lt;label class="label label-success">pelattu</label>
              {% else %}
                &lt;label class="label label-danger">kesken</label>
              {% endif %}
          &lt;/td>
          &lt;td>{{game.added}}&lt;/td>
          &lt;td>&lt;a class="btn btn-default btn-sm" href="{{base_path}}/game/{{game.id}}/edit">Muokkaa&lt;/a>&lt;/td>
        &lt;/tr>
      {% endfor %}
    &lt;/tbody>
  &lt;/table>
{% endblock %}</div>

<p>
  <div class="alert alert-info">
    <h4>Vinkki</h4>
    Sovelluksen näkymät kannattaa jaotella kansioihin tietokohteiden mukaan <code>app/views</code>-kansioon. Kuten huomasit lisäsin tietokohteeni <code>game</code> näkymät kansioon <code>game</code>. Tämä selkeyttää huomattavasti näkymien hallintaa.
  </div>
</p>

<p>
  <div class="alert alert-warning">
    <h4>Muistathan?</h4>
    Muista lisätä kaikkien näkymäsi polkujen eteen, kuten linkkeihin, <code>{{base_path}}</code>, muuten polut osoittavat <code>htdocs</code> kansion juureen, eivätkä oman projektikansiosi juureen.
  </div>
</p>

<p>
  Kuten huomaat, kontrollerissani välittämä <code>games</code>-muuttuja on käytössä näkymässäni. Itse näkymässä ei tapahdu mitään kovin erikoista, käyn <code>{% for game in games %}</code>-blokin sisällä läpi kaikki <code>games</code>-muuttujaan talletetut pelit, jotka annoin näkymälle. <code>for</code>-blokki muistuttaa hyvin paljon <code>foreach</code>-looppia, se tarvitsee vain iteroitavan taulukon ja nimen iteroitavalle alkiolle. Blokin sisällä upotan jokaisen pelin tiedot taulukkoon syntaksilla <code>{{muuttujan_nimi}}</code> ja teen <code>{% if game.played %}</code>-blokin avulla pienen ehtolauseen kaunistaakseni näkymääni. Twigillä voi tehdä siis vaikka mitä, lue <a href="http://twig.sensiolabs.org/doc/templates.html" target="_blank">täältä</a> lisää sen hyödyllisistä ominaisuuksista.
</p>

<p>
  Lisään vielä <code>config/routes.php</code>-tiedostoon seuraavan reitin, jotta toteuttamaani <code>index</code>-metodia kutsuttaisiin sovellukseni polussa <code>/game</code>:
</p>

<div hljs language="php" no-escape>$routes->get('/game', function(){
  GameController::index();
});</div>

<p>
  Luettuasi hieman Twigistä, luo yhdelle oman sovelluksesi tietokohteelle listaus- ja esittelysivu. Pohjana kannattaa käyttää viikolla 2 tekemiäsi käyttöliittymäsuunnitelmia.
</p>

<h3>
  3.2 Dynaamiset reitit
</h3>

<p>
  Haluan pelini esittelysivun poluksi <code>game/ID</code>, jossa <code>ID</code> on näytettävän pelin id. Tämä on helppo toteuttaa käyttämällämme Slim-frameworkilla. Tässä on sovellukseni reitit tällä hetkellä:
</p>

<div hljs language="php" no-escape>// Etusivu (pelien listaussivu)
$routes->get('/', function(){
  GameController::index();
});

// Pelien listaussivu
$routes->get('/game', function(){
  GameController::index();
});

// Pelin esittelysivu
$routes->get('/game/:id', function($id){
  GameController::show($id);
});</div>

<p>
  Kuten huomaat, esittelysivun reittiin <code>/game/:id</code> on upotettu muuttuja <code>id</code>, joka on lisätty polkuun <code>:id</code>-syntaksilla. Nyt kun sovelluksessa menee esimerkiksi polkuun <code>game/1</code>, saa muuttuja arvokseen <code>1</code>. Tätä tietoa voimme käyttää kontrollerissa, hakeaksemme halutun pelin tietokannasta.
</p>

<p>
  <div class="alert alert-info">
    <h4>Vinkki</h4>
    Voit tulostaa koodin seasta viestejä PHP-logeihin <a href="http://php.net/manual/en/function.error-log.php" target="_blank">error_log</a>-funktion avulla. Muistathan, että pääset tarkkailemaan logeja suorittamalla terminaalissa projektisi juuressa komennon <code>bash php_logs.sh</code>. Logit pystyy sulkeamaan näppäilemällä terminaaliin <kbd>ctrl+c</kbd>.
  </div>
</p>

<hr>
<a id="4-lomakkeet-ja-lisaystoiminnot"></a>
<h2>4. Lomakkeet ja lisäystoiminnot</h2>

Olemme tähän asti käsitelleet, miten GET-pyynnöt kulkevat sovelluksemme läpi. Olemme tulleet kuitenkin pisteeseen, jossa haluamme ottaa vastaan syötteitä käyttäjältämme. Miten esimerkiksi käyttäjä voisi lisätä pelin kirjastoonsa?

<h3>4.1 HTTP POST-pyynnöt ja lomakkeet</h3>

<p>
  Kun kirjaudut esimerkiksi sähköpostiisi, lähetät luultavasti lomakkeen kauttaa <strong>POST-pyynnön</strong> palvelimelle, joka kertoo, millä käyttäjätunnuksella ja salasanalla yrität kirjautua sisään. Otetaan käytännön esimerkiksi pyynnöt, mitkä aiheutin, kun kirjauduin selaimellani labtooliin:
</p>

<p>
  <img src="assets/images/post-pyynto.jpg">
</p>

<p>
  Tein siis POST-pyynnön polkuun <code>/sessions</code> ja pyynnön otsakkeina selaimeni lähetti mm. kentät <code>email</code> ja <code>password</code>, joiden sisältö määräytyi täyttämäni kirjautumislomakkeen perusteella. Onnistuneen kirjautumisen jälkeen selaimeni sai palvelimelta uudelleenohjauksen statuskoodilla 302, jonka seurauksena selaimeni teki GET-pyynnön polkuun <code>/courses/8</code>. Palataan uudelleenohjauksiin pian, katsotaan vain ensin, miten lähetämme ja vastaanotamme POST-pyyntöjä sovelluksessamme.
</p>

<p>
  Voimme helposti toteuttaa näkymäämme lomakkeen, joka lähettää POST-pyynnön palvelimellemme. Minä tarvitsen sovellukseeni lomakkeen pelien lisäystä varten, joten luon tiedoston <code>new.html</code> kansioon <code>app/views/game</code>:
</p>

<div hljs language="xml">{% extends "base.html" %}

{% block content %}
  <h1>Lisää peli kirjastoosi</h1>

  <form method="post" action="{{base_path}}/game">
    <div class="form-group">
      <label>Nimi</label>
      <input type="text" name="name" class="form-control">
    </div>

    <div class="form-group">
      <label>Julkaisija</label>
      <input type="text" name="publisher" class="form-control">
    </div>

    <div class="form-group">
      <label>Julkaisupäivä</label>
      <input type="text" name="published" class="form-control">
    </div>

    <div class="form-group">
      <label>Kuvaus</label>
      <textarea name="description" class="form-control"></textarea>
    </div>

    <div class="form-group">
      <button type="submit" class="btn btn-primary">Lisää</button>
    </div>
  </form>
{% endblock %}</div>

<p>
  Lomakkeeni lähettää kenttiensä sisällöt polkuun <code>/game</code>, joka käy ilmi katsomalla <code>form</code>-tagin <code>action</code>-attribuutin arvoa. Muista lisätä polun eteen palvelimella sijaitsevan projektisi kansion nimi, joka löytyy muuttujasta <code>base_path</code>. Lisäksi lomakkeeni metodiksi on määritelty <code>post</code>, joka käy ilmi <code>method</code>-attribuutin arvosta. Metodi olisi voinut olla myös <code>get</code>.
  Olen myös määritellyt jokaiselle lomakkeeni kentälle <code>name</code>-attribuutin, jonka avulla voin myöhemmin viitata kenttään ja hakea sen arvon lomaketta käsittelevässä kontrollerissa.
</p>

<p>
  <div class="alert alert-info">
    <h4>Vinkki</h4>
    Tekstikentät eivät ole suinkaan ainoita lomakkeen elementtejä. Voit lisäksi lähettää lomakkeiden kautta esimerkiksi monivalintakenttiä ja checkboxeja. <a href="http://www.w3schools.com/html/html_form_elements.asp" target="_blank">Täältä</a> löydät listan lomakkeen elementeistä.
  </div>
</p>

<p>
  Seuraavaksi katsomme, miten pääsemme käsiksi lomakkeen lähettämiin tietoihin kontrollerissamme.
</p>

<h3>4.2 Käyttäjän syötteiden käsittely kontrollereissa</h3>

<p>
  Toteuttamani lomake lähettää POST-pyynnön polkuun <code>/game</code>. Aivan kuten GET-pyyntöjen kanssa, seuraavaksi minun täytyy kertoa sovellukseni, mille kontrollerille ja metodille POST-pyyntö polkuun <code>/game</code> tulee ohjata. Tämä on todella helppoa, lisään vain tämän reitin sovellukseni reittien joukkoon:
</p>

<div hljs language="php" no-escape>// ...
// Pelin lisääminen tietokantaan
$routes->post('/game', function(){
  GameController::store();
});

// Pelin lisäyslomakkeen näyttäminen
$routes->get('/game/new', function(){
  GameController::create();
});
// Määritetään reitti game/:id vasta tässä, jottei se mene sekaisin reitin game/new kanssa</div>

<p>
  <div class="alert alert-warning">
    <h4>Muistathan?</h4>
    Slim valitsee määrittämistäsi reiteistä ensimmäisen, joka vastaa pyynnön polkua. Tällöin esimerkiksi pyyntö sovelluksen polkuun <code>game/new</code> saattaa mennä sekaisin reitin <code>game/:id</code>-kanssa. Ongelman ratkaisu on määrittää reitti <code>game/new</code> ennen reittiä <code>game/:id</code>.
  </div>
</p>

<p>
  Eli muutamme vain metodiksi <code>post</code>, aika helppoa eikö? Käyttäjän lähettämän lomakkeen siis käsittelee <code>GameController</code>-luokan metodi <code>store</code>. Katsotaan, mitä siellä tapahtuu:
</p>

<div hljs language="php" no-escape copy-paste-warning>class GameController extends BaseController{
  // ...
  public static function store(){
    // POST-pyynnön muuttujat sijaitsevat $_POST nimisessä assosiaatiolistassa
    $params = $_POST;

    // Alustetaan uusi Game-luokan olion käyttäjän syöttämillä arvoilla
    $game = new Game(array(
      'name' => $params['name'],
      'description' => $params['description'],
      'publisher' => $params['publisher'],
      'published' => $params['published']
    ));

    // Kutsutaan alustamamme olion save metodia, joka tallentaa olion tietokantaan
    $game->save();

    // Ohjataan käyttäjä lisäyksen jälkeen pelin esittelysivulle
    Redirect::to('/game/' . $game->id, array('message' => 'Peli on lisätty kirjastoosi!'));
  }
}</div>


<p>
  Katsotaan, mitä toteuttamassani metodissa oikein tapahtuu. Aluksi otan POST-pyynnön mukana tulleet muuttujat talteen, jotka sisältävät käyttäjän täyttämien kenttien arvot. Ne sijaitsevat <code>$_POST</code>-muuttujassa assosiaatiolistana, jolloin esimerkiksi lomakkeen <code>description</code>-kentän sisältö on <code>$_POST['description']</code>. Assosiaatiolistan avaimet ovat siis lomakkeessa määrittämieni kenttien <code>name</code>-attribuuttien arvoja. Sen jälkeen luon <code>Game</code>-olion pyyntöön liittyvien muuttujien mukaisesti ja kutsun luomani olion metodia <code>save</code>, joka tallentaa sen tietokantaan. Metodissa ei tapahtu mitään muuta kovin kummallista, paitsi se, että se lisää olion <code>id</code>-attribuutiksi tietokantaan lisätyn rivin <code>id</code>-sarakkeen arvon. Se onnistuu seuraavasti:
</p>
<div hljs language="php" no-escape copy-paste-warning>class Game extends BaseModel{
  // Huomaathan, että save-metodi ei ole staattinen!
  public function save(){
    // Lisätään RETURNING id tietokantakyselymme loppuun, niin saamme lisätyn rivin id-sarakkeen arvon
    $query = DB::connection()->prepare('INSERT INTO Game (name, published, publisher, description) VALUES (:name, :published, :publisher, :description) RETURNING id');
    // Muistathan, että olion attribuuttiin pääse syntaksilla $this->attribuutin_nimi
    $query->execute(array('name' => $this->name, 'published' => $this->published, 'publisher' => $this->publisher, 'description' => $this->description));
    // Haetaan kyselyn tuottama rivi, joka sisältää lisätyn rivin id-sarakkeen arvon
    $row = $query->fetch();
    // Asetetaan lisätyn rivin id-sarakkeen arvo oliomme id-attribuutin arvoksi
    $this->id = $row['id'];
  }
}</div>

<p>
  <strong>Huomaathan, että tämä metodi ei ole staattinen, kuten aikaisemmet toteuttamamme metodit</strong>. Saamme metodissamme tietokantaan viimeksi lisätyn rivin lisäämällä SQL-kyselyn loppuun komennon <code>RETURNING id</code>, joka paluttaa lisätyn rivin id-sarakkeen arvon. Lisään sen arvon olioni <code>id</code>-attribuutiksi, jotta voin käyttää sitä kontrollerissani. Muistathan, että tietokantakyselyyn pystyy upottamaan muuttujilla käyttämällä tietokantakyselyssä <code>:upotettavan_muuttujan_nimi</code>-syntaksia (muista <code>:</code>-muuttujan nimen eteen!) ja antamalla <code>execute</code>-metodissa upotettavien muuttujien arvot assosiaatiolistana, jonka avaimina toimivat muuttujien nimet ja arvoina niitä vastaavat arvot. Jos tietokantakyselyiden syntaksi on päässyt unohtumaan, kannattaa virkistää muistia <strong><a href="http://www.tutorialspoint.com/postgresql/postgresql_insert_query.htm" target="_blank">INSERT INTO</a></strong>-lauseiden osalta.
</p>
<p>
  <code>store</code>-metodissa ei siis tapahtu mitään kovin ihmeellistä. Mutta entäs metodin viimeinen rivi <code>Redirect::to(...)</code>? Se on jotain aivan uutta, mitä ihmettä siinä tapahtuu? Puhumme siitä pian.
</p>
<h3>4.3 Ei mennyt niin kuin Strömsössä...</h3>
<img src="assets/images/stromso.jpg" class="pull-right" style="margin-left: 15px; margin-bottom: 15px">
<p>
  Puhutaan seuraavaksi hieman siitä, mitä tehdä, jos hommat eivät mene ihan nappiin. Tietokantaan lisäämisen kanssa moni asia saattoi mennä pieleen. Aloitetaan debuggaaminen <code>GameController</code>-luokan metodista <code>store</code>, jossa meidän täytyy varmistaa, että käyttäjän antamat syötteet ovat kunnossa:
</p>
<div hljs language="php" no-escape>public static function store(){
  $params = $_POST;

  $game = new Game(array(
    'name' => $params['name'],
    'description' => $params['description'],
    'publisher' => $params['publisher'],
    'published' => $params['published']
  ));

  Kint::dump($params);

  $game->save();

  // Muista kommentoida tämä kohta pois!
  // Redirect::to('/game/' . $game->id, array('message' => 'Peli on lisätty kirjastoosi!'));
}</div>
<p>
  Lähetä lisäyslomake ja katso lisäämäsi debuggausviestin sisältö painamalla sinisestä palkista "+"-ikonia. Jos kaikki on kunnossa, siirrytään malliluokan debuggaamiseen:
</p>
<div hljs language="php" no-escape>public function save(){
  $query = DB::connection()->prepare('INSERT INTO Game (name, published, publisher, description) VALUES (:name, :published, :publisher, :description) RETURNING id');
  $query->execute(array('name' => $this->name, 'published' => $this->published, 'publisher' => $this->publisher, 'description' => $this->description));
  $row = $query->fetch();
  Kint::trace();
  Kint::dump($row);
  // $this->id = $row['id'];
}</div>

<p>
  Malliluokan metodissa <code>save</code> on vaaranpaikka: jos tietokantakysely ei tuota tuloksia, niin muuttujan <code>$row</code> arvo on <code>false</code>. Se johtuu joko siitä, että unohdit <code>RETURNING id</code>-komennon kyselyn lopusta, tai yritit syöttää vääränlaisia arvoja tietokantaan (esimerkiksi merkkijonoa numeron sijaan, tai väärää viiteavaimen arvoa). Jos näin on, näet, että muuttujan <code>$row</code> arvo on <code>false</code> lisäämästäsi debuggausviestistä.
</p>

<p>
  Käytin metodissani myös toista <code>Kint</code>-luokan erittäin tärkeää metodia, <code>trace</code>. Se kertoo, mitä kautta metodia kutsuttiin, jolloin pystyt jäljittämään koodisi suoritusta.
</p>

<div style="clear: both"></div>
<h3>4.4 Post/Redirect/Get - PRG</h3>

<img src="assets/images/302.jpg" class="pull-left" style="width: 350px; height: auto; margin-right: 15px; margin-bottom: 15px;">
<p>
  <a href="http://en.wikipedia.org/wiki/Post/Redirect/Get" target="_blank"><strong>Post/Redirect/Get</strong></a> on web-sovelluksien toteutuksessa käytetty suunnittelumalli, joka estää käyttäjää vahingossa lähettämästä samaa lomaketta kahdesti. Siinä käyttäjän lähettämän POST-pyynnön jälkeen selaimelle lähetetään <strong>uudelleenohjauspyyntö</strong> statuskoodilla 302, joka pyytää selainta tekemään GET-pyynnön muualle, kuten esimerkiksi polkuun <code>/game/1</code>.
</p>

<p>
  Kuvitellaan hetki, ettei koko suunnittelumallia olisi olemassakaan, eli emme ohjaisi käyttäjää polkuun <code>/game/ID</code> pelin lisäämisen jälkeen, vaan renderöisimme näkymän <code>game/show.html</code>. Ongelmana on, että vaikka renderöimme näkymän <code>game/show.html</code>, olemme silti polussa <code>/game</code>, joka on lomakkeen kohdepolku. Jos käyttäjä nyt päivittää selaimessaan sivun, lisäyslomake lähetetään uudestaan, vaikka käyttäjä luuli päivittävänsä pelin esittelysivun. Sitä emme halua.
</p>

<p>
  Ohjaamme siis käyttäjän POST-pyynnön jälkeen toiselle sivulle kutsumalla <code>Redirect</code>-luokan metodia <code>to</code>. Parametreikseen metodi ottaa tietenkin polun, mihin käyttäjä ohjataan, mutta lisäksi voit halutessasi antaa toiseksi parametriksi assosiaatiolistan, jonka sisältö voidaan esittää kohdenäkymässä, esimerkiksi pelin esittelysivulla:
</p>
<div style="clear: both"></div>

<div hljs language="xml"><!-- ... -->
<!-- Näkymä games/show.html -->
<div class="alert alert-success">
  {{message}}
</div>
<!-- ... -->
</div>

<p>
  <div class="alert alert-success">
    Peli on lisätty kirjastoosi!
  </div>
</p>

<p>
  Luokan <code>Redirect</code> metodin <code>to</code> toteutus on melko yksinkertainen, se käyttää vain <a href="http://php.net/manual/en/function.header.php" target="_blank">header</a>-funktiota lähettämään selaimelle uudelleenohjauspyynnön seuraavasti:
</p>

<div hljs language="php" no-escape>header('Location: ' . $polku);
// Lopetetaan koodin suorittaminen uudelleenohjauksen jälkeen exit-funktiota kutsumalla
exit();
</div>

<p>
  Toisena parametrina annetun viestin lähettäminen kohteena olevaan näkymään taas tapahtuu <a href="http://www.w3schools.com/php/php_sessions.asp" target="_blank">session</a>-avulla. Puhumme sessioista lisää ensi viikolla. <code>to</code>-metodin toteutukseen voi tutustua tarkemmin kurkkaamalla <code>lib/redirect.php</code>-tiedostoa.
</p>
<hr>
<a id="5-palautuksen-vaatimukset"></a>
<h2>5. Palautuksen vaatimukset</h2>
<ol>
  <li>Toteuta sovellukseesi vähintään yksi malliluokka, jossa on kaikki tietokohteen oliot tietokannasta hakeva metodi (esim. <code>all</code>), tietyllä id:llä varustetun tietokohteen olion tietokannasta hakeva metodi (esim. <code>find</code>) ja tietokohteen olion tietokantaan lisäävä metodi (esim. <code>save</code>). <strong>(1,5p)</strong></li>
  <li>Toteuta malliasi käyttämään kontrolleriin metodit, jotka esittävät tietokohteen listaus-, esittely- ja lisäysnäkymän. Toteuta myös kontrolleriisi metodi, joka mahdollistaa tietokohteen olion lisäämisen tietokantaan käyttäjän lähettämän lomakkeen tiedoilla. <strong>(1,5p)</strong></li>
  <li>Kirjoita <a href="http://advancedkittenry.github.io/aikataulu/koodikatselmointi.html" target="_blank">koodikatselmointi</a> (vapaaehtoinen). <strong>(0-2p)</strong></li>
  <li>
    <strong>Pushaa kaikki tekämäsi muutokset repoosi!</strong>
  </li>
</ol>
<a href="#viikko4" class="btn btn-default pull-right">Viikko 4 <span class="glyphicon glyphicon-chevron-right"></span></a>
